# MVP –ü–ª–∞–Ω –Ω–∞ –Ω–µ–¥–µ–ª—é (40-50 —á–∞—Å–æ–≤)

## üéØ –¶–µ–ª—å MVP
–°–∏—Å—Ç–µ–º–∞ –¥–æ–ª–∂–Ω–∞:
- ‚úÖ –ó–∞–ø—É—Å–∫–∞—Ç—å—Å—è –∏ —Ä–∞–±–æ—Ç–∞—Ç—å —Å—Ç–∞–±–∏–ª—å–Ω–æ
- ‚úÖ –°–æ—Ö—Ä–∞–Ω—è—Ç—å –¥–∞–Ω–Ω—ã–µ –≤ –ë–î (–Ω–µ —Ç–µ—Ä—è—Ç—å –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–µ)
- ‚úÖ –í—ã–ø–æ–ª–Ω—è—Ç—å –±–∞–∑–æ–≤—ã–µ –∑–∞–¥–∞—á–∏ —á–µ—Ä–µ–∑ –∞–≥–µ–Ω—Ç–æ–≤
- ‚úÖ –ò–º–µ—Ç—å —Ä–∞–±–æ—Ç–∞—é—â–∏–π MCP –ø—Ä–æ—Ç–æ–∫–æ–ª –¥–ª—è tools/list –∏ tools/call
- ‚úÖ –ò–º–µ—Ç—å –±–∞–∑–æ–≤—É—é –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å

## ‚ùå –ß—Ç–æ –ù–ï –≤—Ö–æ–¥–∏—Ç –≤ MVP (–æ—Ç–ª–æ–∂–∏—Ç—å)
- –ü–æ–ª–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å LLM (–æ—Å—Ç–∞–≤–∏—Ç—å —Å–∏–º—É–ª—è—Ü–∏—é)
- –ú–µ–∂-–∞–≥–µ–Ω—Ç–Ω–∞—è –∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏—è —á–µ—Ä–µ–∑ message bus
- Frontend –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è (–æ—Å—Ç–∞–≤–∏—Ç—å –º–æ–∫–∏)
- –°–∏—Å—Ç–µ–º–∞ –º–∏–≥—Ä–∞—Ü–∏–π (–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å init-db.sql)
- –í—Å–µ MCP –º–µ—Ç–æ–¥—ã (—Ç–æ–ª—å–∫–æ tools/list –∏ tools/call)
- –°–ª–æ–∂–Ω–∞—è –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–¥–∞—á

---

## üìÖ –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ –¥–Ω—è–º

### –î–µ–Ω—å 1-2 (16 —á–∞—Å–æ–≤): –ò–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö
**–¶–µ–ª—å:** –î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ –ë–î, –Ω–µ —Ç–µ—Ä—è—é—Ç—Å—è –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–µ

### –î–µ–Ω—å 3-4 (16 —á–∞—Å–æ–≤): –ë–∞–∑–æ–≤—ã–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª
**–¶–µ–ª—å:** –°–∏—Å—Ç–µ–º–∞ –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å –∑–∞–¥–∞—á–∏ –∏ –≤—ã–ø–æ–ª–Ω—è—Ç—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã

### –î–µ–Ω—å 5 (8 —á–∞—Å–æ–≤): –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ MCP –ø—Ä–æ—Ç–æ–∫–æ–ª
**–¶–µ–ª—å:** –ë–∞–∑–æ–≤–∞—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –∏ —Ä–∞–±–æ—Ç–∞—é—â–∏–π MCP endpoint

### –î–µ–Ω—å 6-7 (8-10 —á–∞—Å–æ–≤): –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ —Ñ–∏–∫—Å—ã
**–¶–µ–ª—å:** –í—Å–µ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å—Ç–∞–±–∏–ª—å–Ω–æ, –Ω–µ—Ç –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –±–∞–≥–æ–≤

---

## üî¥ –ö–†–ò–¢–ò–ß–ù–û –î–õ–Ø MVP (–î–µ–Ω—å 1-2)

### –ó–∞–¥–∞—á–∞ 1: –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ PostgreSQL (6 —á–∞—Å–æ–≤)

#### –ß—Ç–æ –Ω—É–∂–Ω–æ:
1. –ú–æ–¥—É–ª—å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î
2. –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –º–æ–¥–µ–ª–∏ (—Ç–æ–ª—å–∫–æ –¥–ª—è tasks –∏ tools)
3. –û–±–Ω–æ–≤–∏—Ç—å TaskOrchestrator –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –ë–î

#### –§–∞–π–ª—ã –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è/–∏–∑–º–µ–Ω–µ–Ω–∏—è:

**1. `mcp_server/app/core/database.py`** (–ù–û–í–´–ô)
```python
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import declarative_base
from app.config import settings
import structlog

logger = structlog.get_logger()
Base = declarative_base()

engine = create_async_engine(
    settings.database_url,
    echo=False,
    pool_pre_ping=True,
    pool_size=5,
    max_overflow=10
)

AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False
)

async def get_db() -> AsyncSession:
    async with AsyncSessionLocal() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()

async def init_db():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è - —Ç–∞–±–ª–∏—Ü—ã —É–∂–µ —Å–æ–∑–¥–∞–Ω—ã —á–µ—Ä–µ–∑ init-db.sql"""
    # –ü—Ä–æ—Å—Ç–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
    async with engine.begin() as conn:
        await conn.execute("SELECT 1")
    logger.info("Database connection verified")

async def close_db():
    await engine.dispose()
    logger.info("Database connections closed")
```

**2. `mcp_server/app/core/models/db_models.py`** (–ù–û–í–´–ô - –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –º–æ–¥–µ–ª–∏)
```python
from sqlalchemy import Column, String, Integer, DateTime, Text, JSON, ForeignKey
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
from app.core.database import Base
import uuid

class TaskModel(Base):
    __tablename__ = "tasks"
    __table_args__ = {"schema": "agents"}
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    title = Column(String(500), nullable=False)
    description = Column(Text)
    domain = Column(String(100), nullable=False)
    priority = Column(String(50), default='medium')
    status = Column(String(50), default='pending')
    agent_id = Column(UUID(as_uuid=True))
    input_data = Column(JSON, default={})
    output_data = Column(JSON)
    error_message = Column(Text)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    started_at = Column(DateTime(timezone=True))
    completed_at = Column(DateTime(timezone=True))

class ToolModel(Base):
    __tablename__ = "tools"
    __table_args__ = {"schema": "mcp"}
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(255), unique=True, nullable=False)
    description = Column(Text)
    input_schema = Column(JSON, nullable=False, default={})
    status = Column(String(50), default='active')
    category = Column(String(100))
```

**3. –û–±–Ω–æ–≤–∏—Ç—å `mcp_server/app/core/services/task_orchestrator.py`**
```python
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.core.models.db_models import TaskModel
from app.core.models.mcp_protocol import BusinessTask, TaskRequest, TaskResponse
from datetime import datetime, timedelta

class TaskOrchestrator:
    def __init__(self, db: AsyncSession):
        self.db = db
        self.agent_registry = AgentRegistry()
    
    async def create_task(self, request: TaskRequest) -> TaskResponse:
        # –°–æ–∑–¥–∞—Ç—å –≤ –ë–î
        db_task = TaskModel(
            title=request.title,
            description=request.description,
            domain=request.domain,
            priority=request.priority,
            input_data=request.input_data,
            status="pending"
        )
        self.db.add(db_task)
        await self.db.flush()  # –ü–æ–ª—É—á–∏—Ç—å ID
        
        # –ù–∞–π—Ç–∏ –∞–≥–µ–Ω—Ç–∞ (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞)
        agent_id = await self._find_suitable_agent(db_task)
        
        if agent_id:
            db_task.agent_id = agent_id
            db_task.status = "processing"
            db_task.started_at = datetime.utcnow()
        
        await self.db.commit()
        
        return TaskResponse(
            task_id=str(db_task.id),
            status=db_task.status,
            agent_id=str(agent_id) if agent_id else None
        )
    
    async def get_task(self, task_id: str) -> Optional[BusinessTask]:
        result = await self.db.execute(
            select(TaskModel).where(TaskModel.id == task_id)
        )
        db_task = result.scalar_one_or_none()
        if not db_task:
            return None
        
        return BusinessTask(
            id=str(db_task.id),
            title=db_task.title,
            description=db_task.description,
            domain=db_task.domain,
            priority=db_task.priority,
            status=db_task.status,
            agent_id=str(db_task.agent_id) if db_task.agent_id else None,
            input_data=db_task.input_data,
            output_data=db_task.output_data,
            created_at=db_task.created_at,
            started_at=db_task.started_at,
            completed_at=db_task.completed_at,
            error_message=db_task.error_message
        )
    
    async def list_tasks(self, status: str = None, domain: str = None, limit: int = 50, offset: int = 0) -> List[BusinessTask]:
        query = select(TaskModel)
        
        if status:
            query = query.where(TaskModel.status == status)
        if domain:
            query = query.where(TaskModel.domain == domain)
        
        query = query.order_by(TaskModel.created_at.desc()).limit(limit).offset(offset)
        
        result = await self.db.execute(query)
        db_tasks = result.scalars().all()
        
        return [
            BusinessTask(
                id=str(t.id),
                title=t.title,
                description=t.description,
                domain=t.domain,
                priority=t.priority,
                status=t.status,
                agent_id=str(t.agent_id) if t.agent_id else None,
                input_data=t.input_data,
                output_data=t.output_data,
                created_at=t.created_at,
                started_at=t.started_at,
                completed_at=t.completed_at,
                error_message=t.error_message
            )
            for t in db_tasks
        ]
```

**4. –û–±–Ω–æ–≤–∏—Ç—å `mcp_server/app/main.py`**
```python
from app.core.database import init_db, close_db

@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info("Starting MCP Business AI Server", version=settings.app_version)
    try:
        await init_db()
        logger.info("Services initialized successfully")
    except Exception as e:
        logger.error("Failed to initialize services", error=str(e))
        raise
    yield
    await close_db()
    logger.info("Shutting down MCP Business AI Server")
```

**5. –û–±–Ω–æ–≤–∏—Ç—å `mcp_server/app/api/v1/resources.py`** (–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å dependency injection)
```python
from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.core.services.task_orchestrator import TaskOrchestrator

@router.post("/tasks", response_model=TaskResponse)
async def create_task(
    request: TaskRequest,
    db: AsyncSession = Depends(get_db)
):
    orchestrator = TaskOrchestrator(db)
    return await orchestrator.create_task(request)

@router.get("/tasks/{task_id}", response_model=BusinessTask)
async def get_task(
    task_id: str,
    db: AsyncSession = Depends(get_db)
):
    orchestrator = TaskOrchestrator(db)
    task = await orchestrator.get_task(task_id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    return task
```

**–í—Ä–µ–º—è:** 6 —á–∞—Å–æ–≤

---

### –ó–∞–¥–∞—á–∞ 2: –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Redis –¥–ª—è rate limiting (4 —á–∞—Å–∞)

**1. `mcp_server/app/core/redis_client.py`** (–ù–û–í–´–ô - —É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
```python
import redis.asyncio as redis
from app.config import settings
import structlog

logger = structlog.get_logger()

class RedisClient:
    def __init__(self):
        self.client: redis.Redis = None
    
    async def connect(self):
        try:
            self.client = await redis.from_url(
                settings.redis_url,
                encoding="utf-8",
                decode_responses=True
            )
            await self.client.ping()
            logger.info("Redis connected")
        except Exception as e:
            logger.error("Redis connection failed", error=str(e))
            raise
    
    async def disconnect(self):
        if self.client:
            await self.client.close()
    
    async def zadd(self, key: str, score: float, member: str):
        await self.client.zadd(key, {member: score})
    
    async def zremrangebyscore(self, key: str, min_score: float, max_score: float):
        await self.client.zremrangebyscore(key, min_score, max_score)
    
    async def zcard(self, key: str) -> int:
        return await self.client.zcard(key)
    
    async def expire(self, key: str, seconds: int):
        await self.client.expire(key, seconds)

redis_client = RedisClient()
```

**2. –û–±–Ω–æ–≤–∏—Ç—å `mcp_server/app/middleware/rate_limiting.py`**
```python
from app.core.redis_client import redis_client
import time

class RateLimitingMiddleware:
    async def __call__(self, request: Request, call_next):
        client_id = self._get_client_id(request)
        
        if not await self._check_rate_limit(client_id):
            raise HTTPException(status_code=429, detail="Rate limit exceeded")
        
        await self._record_request(client_id)
        return await call_next(request)
    
    async def _check_rate_limit(self, client_id: str) -> bool:
        now = time.time()
        window_start = now - settings.rate_limit_window
        key = f"rate_limit:{client_id}"
        
        try:
            await redis_client.zremrangebyscore(key, 0, window_start)
            count = await redis_client.zcard(key)
            return count < settings.rate_limit_requests
        except Exception as e:
            logger.error("Rate limit check failed", error=str(e))
            return True  # Fail open
    
    async def _record_request(self, client_id: str):
        now = time.time()
        key = f"rate_limit:{client_id}"
        try:
            await redis_client.zadd(key, now, str(now))
            await redis_client.expire(key, settings.rate_limit_window)
        except Exception as e:
            logger.error("Rate limit record failed", error=str(e))
```

**3. –û–±–Ω–æ–≤–∏—Ç—å `mcp_server/app/main.py`**
```python
from app.core.redis_client import redis_client

@asynccontextmanager
async def lifespan(app: FastAPI):
    try:
        await init_db()
        await redis_client.connect()
        logger.info("Services initialized")
    except Exception as e:
        logger.error("Failed to initialize", error=str(e))
        raise
    yield
    await redis_client.disconnect()
    await close_db()
```

**–í—Ä–µ–º—è:** 4 —á–∞—Å–∞

---

### –ó–∞–¥–∞—á–∞ 3: –û–±–Ω–æ–≤–∏—Ç—å config.py –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏ (1 —á–∞—Å)

**–û–±–Ω–æ–≤–∏—Ç—å `mcp_server/app/config.py`**
```python
class Settings(BaseSettings):
    secret_key: str  # –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –ø–æ–ª–µ
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if not self.secret_key or self.secret_key == "your-secret-key-change-in-production":
            raise ValueError("SECRET_KEY must be set in .env file")
```

**–í—Ä–µ–º—è:** 1 —á–∞—Å

---

### –ó–∞–¥–∞—á–∞ 4: –û–±–Ω–æ–≤–∏—Ç—å health check (1 —á–∞—Å)

**–û–±–Ω–æ–≤–∏—Ç—å `mcp_server/app/api/v1/health.py`**
```python
from app.core.redis_client import redis_client
from app.core.database import engine

@router.get("/")
async def health_check():
    services = {}
    
    # Check Database
    try:
        async with engine.begin() as conn:
            await conn.execute("SELECT 1")
        services["database"] = True
    except:
        services["database"] = False
    
    # Check Redis
    try:
        await redis_client.client.ping()
        services["redis"] = True
    except:
        services["redis"] = False
    
    status = "healthy" if all(services.values()) else "degraded"
    
    return {
        "status": status,
        "services": services,
        "timestamp": datetime.utcnow().isoformat()
    }
```

**–í—Ä–µ–º—è:** 1 —á–∞—Å

**–ò–¢–û–ì–û –î–µ–Ω—å 1-2:** 12 —á–∞—Å–æ–≤

---

## üü† –í–´–°–û–ö–ò–ô –ü–†–ò–û–†–ò–¢–ï–¢ (–î–µ–Ω—å 3-4)

### –ó–∞–¥–∞—á–∞ 5: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å MCP tools/list –∏ tools/call (6 —á–∞—Å–æ–≤)

**1. –û–±–Ω–æ–≤–∏—Ç—å `mcp_server/app/core/services/tool_registry.py`** (—Å–æ—Ö—Ä–∞–Ω—è—Ç—å –≤ –ë–î)
```python
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.core.models.db_models import ToolModel

class ToolRegistry:
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def get_all_tools(self) -> Dict[str, MCPTool]:
        result = await self.db.execute(select(ToolModel))
        tools = result.scalars().all()
        
        return {
            tool.name: MCPTool(
                name=tool.name,
                description=tool.description,
                input_schema=tool.input_schema,
                status=ToolStatus(tool.status),
                category=tool.category,
                tags=tool.tags or []
            )
            for tool in tools
        }
    
    async def get_tool(self, tool_name: str) -> Optional[MCPTool]:
        result = await self.db.execute(
            select(ToolModel).where(ToolModel.name == tool_name)
        )
        tool = result.scalar_one_or_none()
        if not tool:
            return None
        
        return MCPTool(
            name=tool.name,
            description=tool.description,
            input_schema=tool.input_schema,
            status=ToolStatus(tool.status),
            category=tool.category,
            tags=tool.tags or []
        )
    
    async def execute_tool(self, tool_name: str, parameters: Dict[str, Any], agent_id: Optional[str] = None) -> ToolExecution:
        # –ü–æ–ª—É—á–∏—Ç—å tool –∏–∑ –ë–î
        tool = await self.get_tool(tool_name)
        if not tool:
            raise ToolExecutionException(tool_name, "Tool not found")
        
        # –í—ã–ø–æ–ª–Ω–∏—Ç—å (–æ—Å—Ç–∞–≤–∏—Ç—å —Å–∏–º—É–ª—è—Ü–∏—é –¥–ª—è MVP)
        start_time = time.time()
        try:
            result = await self._execute_tool_implementation(tool, parameters)
            execution_time = time.time() - start_time
            
            # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –ë–î (–µ—Å–ª–∏ –µ—Å—Ç—å —Ç–∞–±–ª–∏—Ü–∞ tool_executions)
            # –ü–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º
            
            return ToolExecution(
                tool_name=tool_name,
                agent_id=agent_id or "system",
                parameters=parameters,
                result=result,
                execution_time=execution_time
            )
        except Exception as e:
            return ToolExecution(
                tool_name=tool_name,
                agent_id=agent_id or "system",
                parameters=parameters,
                error=str(e),
                execution_time=time.time() - start_time
            )
```

**2. –û–±–Ω–æ–≤–∏—Ç—å `mcp_server/app/main.py`** (MCP handlers)
```python
async def handle_tools_list(message: Dict[str, Any], correlation_id: str):
    from app.core.services.tool_registry import ToolRegistry
    from app.core.database import get_db
    
    async for db in get_db():
        tool_registry = ToolRegistry(db)
        tools = await tool_registry.get_all_tools()
        
        mcp_tools = [
            {
                "name": tool.name,
                "description": tool.description,
                "inputSchema": tool.input_schema
            }
            for tool in tools.values()
        ]
        
        return {
            "jsonrpc": "2.0",
            "id": message.get("id"),
            "result": {"tools": mcp_tools}
        }

async def handle_tools_call(message: Dict[str, Any], correlation_id: str):
    from app.core.services.tool_registry import ToolRegistry
    from app.core.database import get_db
    
    params = message.get("params", {})
    tool_name = params.get("name")
    arguments = params.get("arguments", {})
    
    if not tool_name:
        return {
            "jsonrpc": "2.0",
            "id": message.get("id"),
            "error": {"code": -32602, "message": "Tool name required"}
        }
    
    async for db in get_db():
        tool_registry = ToolRegistry(db)
        try:
            execution = await tool_registry.execute_tool(tool_name, arguments)
            
            return {
                "jsonrpc": "2.0",
                "id": message.get("id"),
                "result": {
                    "content": [{"type": "text", "text": str(execution.result)}],
                    "isError": execution.error is not None
                }
            }
        except Exception as e:
            return {
                "jsonrpc": "2.0",
                "id": message.get("id"),
                "error": {"code": -32603, "message": str(e)}
            }
```

**–í—Ä–µ–º—è:** 6 —á–∞—Å–æ–≤

---

### –ó–∞–¥–∞—á–∞ 6: –ò—Å–ø—Ä–∞–≤–∏—Ç—å Agent Registry (2 —á–∞—Å–∞)

**–û–±–Ω–æ–≤–∏—Ç—å `mcp_server/app/core/services/agent_registry.py`**
```python
async def create_agent(self, request: AgentRequest) -> Agent:
    async with self._lock:
        if request.type not in self.agent_types:
            raise ValueError(f"Unknown agent type: {request.type}")
        
        agent_id = str(uuid.uuid4())  # –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –î–û —Å–æ–∑–¥–∞–Ω–∏—è
        
        agent_class = self.agent_types[request.type]
        agent = agent_class(
            agent_id=agent_id,  # –ü–µ—Ä–µ–¥–∞—Ç—å ID
            name=request.name,
            agent_type=request.type,
            capabilities=request.capabilities,
            config=request.config
        )
        
        self.agents[agent.id] = agent
        await agent.start()
        
        return Agent(
            id=agent.id,
            name=agent.name,
            type=agent.type,
            description=request.description,
            capabilities=agent.capabilities,
            status=agent.status,
            tasks_completed=agent.tasks_completed,
            last_activity=agent.last_activity,
            config=agent.config
        )

async def get_agent(self, agent_id: str) -> Optional[Agent]:
    async with self._lock:
        agent = self.agents.get(agent_id)
        if not agent:
            return None
        
        current_task_id = str(agent.current_task.id) if agent.current_task else None  # –ë–µ–∑–æ–ø–∞—Å–Ω–æ
        
        return Agent(
            id=agent.id,
            name=agent.name,
            type=agent.type,
            description="",
            capabilities=agent.capabilities,
            status=agent.status,
            current_task_id=current_task_id,
            tasks_completed=agent.tasks_completed,
            last_activity=agent.last_activity,
            config=agent.config
        )
```

**–í—Ä–µ–º—è:** 2 —á–∞—Å–∞

---

### –ó–∞–¥–∞—á–∞ 7: –ë–∞–∑–æ–≤–∞—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å API –∫–ª—é—á–µ–π (2 —á–∞—Å–∞)

**1. –û–±–Ω–æ–≤–∏—Ç—å `mcp_server/app/middleware/auth.py`**
```python
from passlib.context import CryptContext
import hashlib

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class AuthMiddleware:
    async def _verify_api_key(self, api_key: str) -> bool:
        # –î–ª—è MVP: –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—Ç–∏–≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è
        # –í production - –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤ –ë–î
        valid_key = os.getenv("API_KEY")
        if not valid_key:
            # –ï—Å–ª–∏ –Ω–µ—Ç API_KEY –≤ env, —Ä–∞–∑—Ä–µ—à–∏—Ç—å –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
            return True
        
        # –ü—Ä–æ—Å—Ç–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ (–¥–ª—è MVP)
        return api_key == valid_key
```

**2. –û–±–Ω–æ–≤–∏—Ç—å `.env.example`**
```env
API_KEY=your-api-key-here
SECRET_KEY=your-secret-key-here
```

**–í—Ä–µ–º—è:** 2 —á–∞—Å–∞

**–ò–¢–û–ì–û –î–µ–Ω—å 3-4:** 10 —á–∞—Å–æ–≤

---

## üü° –°–†–ï–î–ù–ò–ô –ü–†–ò–û–†–ò–¢–ï–¢ (–î–µ–Ω—å 5)

### –ó–∞–¥–∞—á–∞ 8: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ —Ñ–∏–∫—Å—ã (8 —á–∞—Å–æ–≤)

1. –ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ endpoints
2. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –≤ –ë–î
3. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å rate limiting
4. –ò—Å–ø—Ä–∞–≤–∏—Ç—å –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –±–∞–≥–∏
5. –û–±–Ω–æ–≤–∏—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é

**–í—Ä–µ–º—è:** 8 —á–∞—Å–æ–≤

---

## üìã –ß–µ–∫–ª–∏—Å—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è

### –î–µ–Ω—å 1-2 (12 —á–∞—Å–æ–≤)
- [ ] –°–æ–∑–¥–∞—Ç—å `database.py`
- [ ] –°–æ–∑–¥–∞—Ç—å `db_models.py` (–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –º–æ–¥–µ–ª–∏)
- [ ] –û–±–Ω–æ–≤–∏—Ç—å `task_orchestrator.py` –¥–ª—è –ë–î
- [ ] –û–±–Ω–æ–≤–∏—Ç—å `resources.py` –¥–ª—è dependency injection
- [ ] –°–æ–∑–¥–∞—Ç—å `redis_client.py`
- [ ] –û–±–Ω–æ–≤–∏—Ç—å `rate_limiting.py` –¥–ª—è Redis
- [ ] –û–±–Ω–æ–≤–∏—Ç—å `main.py` –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
- [ ] –û–±–Ω–æ–≤–∏—Ç—å `config.py` –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏
- [ ] –û–±–Ω–æ–≤–∏—Ç—å `health.py` –¥–ª—è —Ä–µ–∞–ª—å–Ω—ã—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫

### –î–µ–Ω—å 3-4 (10 —á–∞—Å–æ–≤)
- [ ] –û–±–Ω–æ–≤–∏—Ç—å `tool_registry.py` –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ë–î
- [ ] –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å `handle_tools_list` –≤ `main.py`
- [ ] –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å `handle_tools_call` –≤ `main.py`
- [ ] –ò—Å–ø—Ä–∞–≤–∏—Ç—å `agent_registry.py` (ID –∏ current_task)
- [ ] –û–±–Ω–æ–≤–∏—Ç—å `auth.py` –¥–ª—è API –∫–ª—é—á–µ–π

### –î–µ–Ω—å 5 (8 —á–∞—Å–æ–≤)
- [ ] –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö endpoints
- [ ] –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
- [ ] –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–∞–≥–æ–≤
- [ ] –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏

---

## üöÄ –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç

### 1. –°–æ–∑–¥–∞—Ç—å .env
```env
DATABASE_URL=postgresql+asyncpg://postgres:password@localhost:5432/mcp_db
REDIS_URL=redis://localhost:6379
SECRET_KEY=$(python -c "import secrets; print(secrets.token_urlsafe(32))")
API_KEY=mcp-api-key-12345
```

### 2. –ó–∞–ø—É—Å—Ç–∏—Ç—å –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä—É
```bash
docker-compose up -d postgres redis
```

### 3. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
```bash
cd mcp_server
pip install -r requirements.txt
```

### 4. –ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–µ—Ä–≤–µ—Ä
```bash
uvicorn app.main:app --reload
```

### 5. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å
```bash
curl http://localhost:8000/api/v1/health
curl http://localhost:8000/api/v1/tools
```

---

## ‚ö†Ô∏è –í–∞–∂–Ω—ã–µ –∑–∞–º–µ—á–∞–Ω–∏—è

1. **–î–ª—è MVP –æ—Å—Ç–∞–≤–ª—è–µ–º —Å–∏–º—É–ª—è—Ü–∏—é LLM** - —Ä–µ–∞–ª—å–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –∑–∞–π–º–µ—Ç –±–æ–ª—å—à–µ –≤—Ä–µ–º–µ–Ω–∏
2. **Frontend –æ—Å—Ç–∞–µ—Ç—Å—è —Å –º–æ–∫–∞–º–∏** - –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–∞ –¥–ª—è MVP
3. **–ò—Å–ø–æ–ª—å–∑—É–µ–º init-db.sql** - –º–∏–≥—Ä–∞—Ü–∏–∏ –æ—Ç–ª–æ–∂–µ–Ω—ã
4. **–£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è** - –¥–ª—è production –Ω—É–∂–Ω–∞ –ë–î —Å API –∫–ª—é—á–∞–º–∏

---

## üìä –ò—Ç–æ–≥–æ–≤–∞—è –æ—Ü–µ–Ω–∫–∞

- **–î–µ–Ω—å 1-2:** 12 —á–∞—Å–æ–≤
- **–î–µ–Ω—å 3-4:** 10 —á–∞—Å–æ–≤  
- **–î–µ–Ω—å 5:** 8 —á–∞—Å–æ–≤
- **–†–µ–∑–µ—Ä–≤:** 2 —á–∞—Å–∞

**–ò–¢–û–ì–û: 32 —á–∞—Å–∞** (4 —Ä–∞–±–æ—á–∏—Ö –¥–Ω—è –ø–æ 8 —á–∞—Å–æ–≤)

–≠—Ç–æ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ –¥–ª—è –Ω–µ–¥–µ–ª–∏ —Ä–∞–±–æ—Ç—ã!

